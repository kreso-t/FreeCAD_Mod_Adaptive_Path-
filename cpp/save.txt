IntPoint p1; // 1st intersection point of cleared path with tool in new POS
		IntPoint p2; // 2nd intersection point of cleared path with tool in new POS
		IntPoint p3; // 1st intersection point of cleared path with tool in old POS
		IntPoint p4; // 2nd intersection point of cleared path with tool in old POS
		IntPoint p5; // 1st intersection point of tool in new position and tool in old position (circle to circle intersect)
		IntPoint p6; // 2nd intersection point of tool in new position and tool in old position (circle to circle intersect)
		vector<DoublePoint> inters;
		for(const Path & path: cleared_paths) {
			size_t size=path.size();
			for(size_t i=0;i<size;i++) {
				// path segment points
				const IntPoint * sp1=&path.at(i>0?i-1:size-1);
				const IntPoint * sp2=&path.at(i);
				if(Line2CircleIntersect(c2, toolRadiusScaled, *sp1,*sp2,inters)) {
					if(inters.size()==2) {
						p1.X=inters[0].X; p1.Y=inters[0].Y;
						p2.X=inters[1].X, p2.Y=inters[1].Y;
						haveP1=true; haveP2=true;
					} else {
						if(!haveP1) {
							p1.X=inters[0].X; p1.Y=inters[0].Y;
							haveP1=true;
						}
						else {
							p2.X=inters[0].X, p2.Y=inters[0].Y;
							haveP2=true;
						}
					}
				}
				if(haveP1 && haveP2) break;
			}
			if(haveP1 && haveP2) break;
		}
		if(!haveP1 || !haveP2) return 0.0;  // not cutting

		DrawCircle(c1,toolRadiusScaled,0);
		DrawCircle(c2,toolRadiusScaled,1);
		DrawCircle(p1,scaleFactor/2,2);
		DrawCircle(p2,scaleFactor/2,3);

		//return optimalCutAreaPD * sqrt(DistanceSqrd(c1,c2)) ;
		// found intersections with new tool -- see if there are points p3,p4, intersection of cleared line with old tool
		bool haveP3=false;
		bool haveP4=false;
		for(const Path & path: cleared_paths) {
			size_t size=path.size();
			for(size_t i=0;i<size;i++) {
				// path segment points
				const IntPoint * sp1=&path.at(i>0?i-1:size-1);
				const IntPoint * sp2=&path.at(i);
				if(Line2CircleIntersect(c1,toolRadiusScaled, *sp1,*sp2,inters)) {
					if(inters.size()==2) {
						p3.X=inters[0].X; p3.Y=inters[0].Y;
						p4.X=inters[1].X, p4.Y=inters[1].Y;
						haveP3=true; haveP4=true;
					} else {
						if(!haveP3) {
							p3.X=inters[0].X; p3.Y=inters[0].Y;
							haveP3=true;
						}
						else {
							p4.X=inters[0].X, p4.Y=inters[0].Y;
							haveP4=true;
						}
					}
				}
				if(haveP3 && haveP4) break;
			}
			if(haveP3 && haveP4) break;
		}
		pair<DoublePoint,DoublePoint> cirInter;
		if(Circle2CircleIntersect(c1,c2,toolRadiusScaled,cirInter)) {
			p5.X=cirInter.first.X; p5.Y=cirInter.first.Y;
			p6.X=cirInter.second.X; p6.Y=cirInter.second.Y;
		}

		// resolve the geometry case and calculate area
		if(!haveP3) { // case 1 - no intersention with old tool
			cout<< "case 1" << endl;
			double fi1=Angle3Points(p1,c2,p2);
        	double A = fi1*rsqrd_2; // area of sector

			Path p;
			p<<p1<<c2<<p2;  // triangle to subtract
	        double B = fabs(Area(p));

			cout<< "case 1 fi1: " << fi1 << " A:" << A << " B" << B << endl;
        	area= A-B; //resulting area
		} ///else if (PointSideOfLine(p1,p2,p6)>0) {
		else {
			cout<< "case 2" << endl;

			DrawCircle(p3,scaleFactor/2,4);
			DrawCircle(p4,scaleFactor/2,5);

			//case2 intersecting both tools, p6 on the left of p1--p2
			double fi1=Angle3Points(p1,c2,p2);
			double A = fi1*rsqrd_2;
			Path p;
			p<<p1<<c2<<p2;  // triangle to subtract
			double B=fabs(Area(p));

		    double fi2=Angle3Points(p3,c1,p4);
			double C = fi2*rsqrd_2;
			p.clear();
			p <<p3<<c1<<p4;  // triangle to subtract
        	double D = fabs(Area(p));

			cout<< "case 2 fi1: " << fi1 << " A:" << A  << " B:" << B << " fi2:" <<  fi2 << " C:" << C << " D:" << D << endl;
        	area=A-B-(C-D); //resulting area
		}
		// else {
		// 	cout<< "case 3" << endl;
		// 	//#case 3: p6 on the right
		// 	double fi1=Angle3Points(p1,c2,p2);
		// 	double A=fi1*rsqrd_2;

		// 	DrawCircle(p3,scaleFactor/2,2);
		// 	DrawCircle(p6,scaleFactor/2,3);

		// 	double fi2=Angle3Points(p3,c1,p6);
		// 	double B=fi2*rsqrd_2;
		// 	IntPoint px;
		// 	if(!IntersectionPoint(c2,p6,c1,p2,px)) {
		// 		if(!IntersectionPoint(p1,c2,c1,p2,px)) {
		// 			cerr<<"ERROR - could not find itermediate point" << endl;
		// 			return A-B;
		// 		}
		// 	}
		// 	DrawCircle(px,scaleFactor/2,3);

		// 	Path p;
		// 	p<<c1<<px<<p6;
		// 	double C=fabs(Area(p));

		// 	p.clear();
		// 	p<<p1<<c2<<px<<p2;
		// 	double D=fabs(Area(p));
		// 	return A-(B-C)-D; // resulting area
		// }

		//cout << "p1:" << p1->X << "," << p1->Y << "   p2:" << p2->X << ","  << p2->Y << " " << endl;

		// double dist = DistanceSqrd(toolPos,newToolPos);
		// if(dist<NTOL) return 0;
		// Perf_CalcCutArea.Start();
		// // 1. find differene beween old and new tool shape
		// Path oldTool;
		// Path newTool;
		// TranslatePath(toolGeometry,oldTool,toolPos);
		// TranslatePath(toolGeometry,newTool,newToolPos);
		// clip.Clear();
		// clip.AddPath(newTool, PolyType::ptSubject, true);
		// clip.AddPath(oldTool, PolyType::ptClip, true);
		// Paths toolDiff;
		// clip.Execute(ClipType::ctDifference,toolDiff);

		// // 2. difference to cleared
		// clip.Clear();
		// clip.AddPaths(toolDiff,PolyType::ptSubject, true);
		// clip.AddPaths(cleared_paths,PolyType::ptClip, true);
		// Paths cutAreaPoly;
		// clip.Execute(ClipType::ctDifference, cutAreaPoly);

		// // calculate resulting area
		// double areaSum=0;
		// for(Path &path : cutAreaPoly) {
		// 	areaSum += fabs(Area(path));
		// }
		// Perf_CalcCutArea.Stop();
		// return areaSum;